// Flood Alert System for Vietnam

class FloodAlertSystem {
    constructor() {
        this.badge = document.getElementById('floatingAlertBadge');
        this.banner = document.getElementById('floodAlertBanner');
        this.modal = document.getElementById('floodAlertModal');
        this.alertTitle = document.getElementById('alertTitle');
        this.alertMessage = document.getElementById('alertMessage');
        this.messageContainer = document.getElementById('floodAlertMessage');
        this.badgeCount = document.getElementById('badgeCount');
        
        this.currentAlerts = [];
        this.audioContextUnlocked = false;
        this.pendingSound = null; // Store alert level if sound was blocked
        
        this.setupEventListeners();
        this.unlockAudioContext();
    }
    
    /**
     * Unlock audio context on first user interaction
     */
    unlockAudioContext() {
        const unlock = () => {
            if (!this.audioContextUnlocked) {
                try {
                    // Create a dummy audio context to unlock
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = ctx.createOscillator();
                    const gainNode = ctx.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    gainNode.gain.setValueAtTime(0, ctx.currentTime);
                    
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + 0.001);
                    
                    this.audioContextUnlocked = true;
                    
                    // If there was a pending sound, play it now
                    if (this.pendingSound) {
                        setTimeout(() => {
                            this.playAlertSound();
                            this.pendingSound = null;
                        }, 100);
                    }
                } catch (error) {
                    console.log('Audio unlock failed:', error);
                }
            }
        };
        
        // Try to unlock on various user interactions
        ['click', 'touchstart', 'keydown', 'mousedown'].forEach(event => {
            document.addEventListener(event, unlock, { once: true, passive: true });
        });
    }

    setupEventListeners() {
        // Badge click - show banner
        this.badge.addEventListener('click', () => {
            this.unlockAudioContext();
            this.showBanner();
        });
        
        // Banner buttons
        document.getElementById('closeAlert').addEventListener('click', () => this.hideBanner());
        document.getElementById('viewAlertDetails').addEventListener('click', () => this.showModal());
        
        // Modal buttons
        document.getElementById('closeFloodModal').addEventListener('click', () => this.hideModal());
        document.getElementById('confirmFloodAlert').addEventListener('click', () => {
            this.hideModal();
            this.hideBanner();
            this.hideBadge();
        });
        
        // Click outside modal to close
        this.modal.addEventListener('click', (e) => {
            if (e.target === this.modal || e.target.classList.contains('flood-alert-overlay')) {
                this.hideModal();
            }
        });
        
        // Unlock audio on any user interaction with the page
        ['click', 'touchstart', 'keydown'].forEach(event => {
            document.addEventListener(event, () => {
                if (this.pendingSound && this.currentAlerts.length > 0) {
                    // Small delay to ensure audio context is ready
                    setTimeout(() => {
                        this.playAlertSound();
                        this.pendingSound = null;
                    }, 100);
                }
            }, { once: false, passive: true });
        });
    }

    /**
     * Check weather data for flood risks
     */
    checkFloodRisk(weatherData) {
        const alerts = [];
        const current = weatherData.current;
        const forecast = weatherData.forecast;
        
        // Check 1: Weather API Alerts - Ph√¢n lo·∫°i theo m·ª©c ƒë·ªô nghi√™m tr·ªçng
        if (weatherData.alerts && weatherData.alerts.alert && weatherData.alerts.alert.length > 0) {
            weatherData.alerts.alert.forEach(alert => {
                // Ph√¢n lo·∫°i d·ª±a tr√™n severity t·ª´ API
                let level = 'danger';
                const severity = alert.severity?.toLowerCase() || '';
                const event = alert.event?.toLowerCase() || '';
                
                if (severity.includes('extreme') || event.includes('hurricane') || event.includes('typhoon') || event.includes('tornado')) {
                    level = 'extreme';
                } else if (severity.includes('severe') || event.includes('flood') || event.includes('flash flood')) {
                    level = 'extreme';
                } else if (event.includes('warning')) {
                    level = 'danger';
                } else {
                    level = 'warning';
                }
                
                alerts.push({
                    level: level,
                    title: alert.event,
                    description: alert.headline,
                    details: alert.desc,
                    source: 'WeatherAPI Alert'
                });
            });
        }
        
        // Check 2: Heavy Rain Detection - Ph√¢n lo·∫°i theo l∆∞·ª£ng m∆∞a
        const condition = current.condition.text.toLowerCase();
        const rainfall = current.precip_mm || 0;
        
        if (condition.includes('heavy rain') || condition.includes('torrential') || 
            condition.includes('m∆∞a to') || condition.includes('m∆∞a l·ªõn')) {
            
            if (rainfall > 100) {
                // EXTREME: M∆∞a c·ª±c l·ªõn
                alerts.push({
                    level: 'extreme',
                    title: 'C·∫£nh B√°o C·ª±c K·ª≥ Nguy Hi·ªÉm: M∆∞a C·ª±c L·ªõn',
                    description: `üö® M∆∞a c·ª±c l·ªõn v·ªõi l∆∞·ª£ng m∆∞a ${rainfall}mm! Nguy c∆° l≈© qu√©t v√† ng·∫≠p √∫ng nghi√™m tr·ªçng!`,
                    details: 'N∆Ø·ªöC C√ì TH·ªÇ D√ÇNG CAO R·∫§T NHANH! Di chuy·ªÉn ngay l·∫≠p t·ª©c ƒë·∫øn n∆°i cao, tr√°nh xa s√¥ng su·ªëi. G·ªçi 113 n·∫øu c·∫ßn c·ª©u h·ªô!',
                    source: 'H·ªá th·ªëng ph√°t hi·ªán t·ª± ƒë·ªông'
                });
            } else if (rainfall > 70) {
                // DANGER: M∆∞a r·∫•t to
                alerts.push({
                    level: 'danger',
                    title: 'C·∫£nh B√°o Nguy Hi·ªÉm: M∆∞a R·∫•t To',
                    description: `ƒêang c√≥ m∆∞a r·∫•t to v·ªõi l∆∞·ª£ng m∆∞a ${rainfall}mm. Nguy c∆° l≈© l·ª•t cao!`,
                    details: 'L∆∞·ª£ng m∆∞a v∆∞·ª£t ng∆∞·ª°ng nguy hi·ªÉm. H√£y di chuy·ªÉn ƒë·∫øn n∆°i an to√†n ngay l·∫≠p t·ª©c.',
                    source: 'H·ªá th·ªëng ph√°t hi·ªán t·ª± ƒë·ªông'
                });
            } else if (rainfall > 50) {
                // DANGER: M∆∞a to
                alerts.push({
                    level: 'danger',
                    title: 'C·∫£nh B√°o: M∆∞a L·ªõn',
                    description: `ƒêang c√≥ m∆∞a l·ªõn v·ªõi l∆∞·ª£ng m∆∞a ${rainfall}mm. C√≥ nguy c∆° ng·∫≠p l·ª•t.`,
                    details: 'L∆∞·ª£ng m∆∞a cao. H√£y chu·∫©n b·ªã ph∆∞∆°ng √°n di chuy·ªÉn v√† theo d√µi t√¨nh h√¨nh.',
                    source: 'H·ªá th·ªëng ph√°t hi·ªán t·ª± ƒë·ªông'
                });
            } else if (rainfall > 30) {
                // WARNING: M∆∞a v·ª´a
                alerts.push({
                    level: 'warning',
                    title: 'C·∫£nh B√°o: M∆∞a To',
                    description: `ƒêang c√≥ m∆∞a to v·ªõi l∆∞·ª£ng m∆∞a ${rainfall}mm. C√≥ nguy c∆° ng·∫≠p √∫ng.`,
                    details: 'C·∫ßn theo d√µi t√¨nh h√¨nh v√† chu·∫©n b·ªã ph∆∞∆°ng √°n di chuy·ªÉn.',
                    source: 'H·ªá th·ªëng ph√°t hi·ªán t·ª± ƒë·ªông'
                });
            }
        }
        
        // Check 3: Forecast Heavy Rain - Ph√¢n lo·∫°i theo l∆∞·ª£ng m∆∞a d·ª± b√°o
        if (forecast && forecast.forecastday) {
            forecast.forecastday.forEach((day, index) => {
                const dayRainfall = day.day.totalprecip_mm || 0;
                const rainChance = day.day.daily_chance_of_rain || 0;
                const maxWind = day.day.maxwind_kph || 0;
                
                if (dayRainfall > 150 && rainChance > 80 && maxWind > 80) {
                    // EXTREME: D·ª± b√°o b√£o l·ªõn
                    const date = new Date(day.date);
                    const dateStr = date.toLocaleDateString('vi-VN', { 
                        weekday: 'long', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                    
                    alerts.push({
                        level: 'extreme',
                        title: 'D·ª± B√°o C·ª±c K·ª≥ Nguy Hi·ªÉm: B√£o L·ªõn',
                        description: `${dateStr}: D·ª± b√°o b√£o l·ªõn v·ªõi m∆∞a ${dayRainfall}mm, gi√≥ ${Math.round(maxWind)} km/h (${rainChance}% kh·∫£ nƒÉng)`,
                        details: 'D·ª∞ B√ÅO THI√äN TAI NGHI√äM TR·ªåNG! Chu·∫©n b·ªã s·∫µn s√†ng di chuy·ªÉn ƒë·∫øn n∆°i an to√†n. Theo d√µi c·∫£nh b√°o ch√≠nh th·ª©c.',
                        source: 'D·ª± b√°o WeatherAPI'
                    });
                } else if (dayRainfall > 120 && rainChance > 75) {
                    // DANGER: D·ª± b√°o m∆∞a r·∫•t l·ªõn
                    const date = new Date(day.date);
                    const dateStr = date.toLocaleDateString('vi-VN', { 
                        weekday: 'long', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                    
                    alerts.push({
                        level: 'danger',
                        title: 'D·ª± B√°o Nguy Hi·ªÉm: M∆∞a R·∫•t L·ªõn',
                        description: `${dateStr}: D·ª± b√°o m∆∞a r·∫•t l·ªõn v·ªõi l∆∞·ª£ng m∆∞a ${dayRainfall}mm (${rainChance}% kh·∫£ nƒÉng m∆∞a)`,
                        details: 'Nguy c∆° l≈© l·ª•t v√† ng·∫≠p √∫ng r·∫•t cao. H√£y chu·∫©n b·ªã ph∆∞∆°ng √°n di chuy·ªÉn v√† theo d√µi s√°t t√¨nh h√¨nh.',
                        source: 'D·ª± b√°o WeatherAPI'
                    });
                } else if (dayRainfall > 80 && rainChance > 70) {
                    // WARNING: D·ª± b√°o m∆∞a l·ªõn
                    const date = new Date(day.date);
                    const dateStr = date.toLocaleDateString('vi-VN', { 
                        weekday: 'long', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                    
                    alerts.push({
                        level: 'warning',
                        title: 'D·ª± B√°o: M∆∞a L·ªõn',
                        description: `${dateStr}: D·ª± b√°o m∆∞a l·ªõn v·ªõi l∆∞·ª£ng m∆∞a ${dayRainfall}mm (${rainChance}% kh·∫£ nƒÉng m∆∞a)`,
                        details: 'Nguy c∆° l≈© l·ª•t v√† ng·∫≠p √∫ng cao trong nh·ªØng ng√†y t·ªõi. H√£y theo d√µi s√°t t√¨nh h√¨nh.',
                        source: 'D·ª± b√°o WeatherAPI'
                    });
                }
            });
        }
        
        // Check 4: Thunder + Heavy Rain = Storm Risk - Ph√¢n lo·∫°i theo c∆∞·ªùng ƒë·ªô gi√≥
        if (condition.includes('thunder') && 
            (condition.includes('rain') || condition.includes('m∆∞a'))) {
            
            const windSpeed = current.wind_kph || 0;
            
            if (windSpeed > 100 && rainfall > 50) {
                // EXTREME: B√£o m·∫°nh
                alerts.push({
                    level: 'extreme',
                    title: 'C·∫£nh B√°o C·ª±c K·ª≥ Nguy Hi·ªÉm: B√£o M·∫°nh',
                    description: `üö® ƒêANG C√ì B√ÉO M·∫†NH! Gi√≥ ${Math.round(windSpeed)} km/h + m∆∞a ${rainfall}mm. R·∫§T NGUY HI·ªÇM!`,
                    details: 'C·ª∞C K·ª≤ NGUY HI·ªÇM! ·ªû trong nh√† ki√™n c·ªë, tr√°nh xa c·ª≠a s·ªï v√† c·ª≠a ra v√†o. Kh√¥ng ra ngo√†i trong m·ªçi tr∆∞·ªùng h·ª£p!',
                    source: 'H·ªá th·ªëng ph√°t hi·ªán t·ª± ƒë·ªông'
                });
            } else if (windSpeed > 70 && rainfall > 30) {
                // DANGER: B√£o
                alerts.push({
                    level: 'danger',
                    title: 'C·∫£nh B√°o Nguy Hi·ªÉm: Gi√¥ng B√£o',
                    description: `ƒêang c√≥ gi√¥ng b√£o v·ªõi gi√≥ m·∫°nh ${Math.round(windSpeed)} km/h v√† m∆∞a ${rainfall}mm`,
                    details: 'Nguy hi·ªÉm! H√£y ·ªü trong nh√† v√† tr√°nh xa c·ª≠a s·ªï. Kh√¥ng ra ngo√†i khi kh√¥ng c·∫ßn thi·∫øt.',
                    source: 'H·ªá th·ªëng ph√°t hi·ªán t·ª± ƒë·ªông'
                });
            } else if (windSpeed > 50) {
                // WARNING: Gi√¥ng t·ªë
                alerts.push({
                    level: 'warning',
                    title: 'C·∫£nh B√°o: Gi√¥ng T·ªë',
                    description: `C√≥ gi√¥ng t·ªë v·ªõi gi√≥ ${Math.round(windSpeed)} km/h`,
                    details: 'C·∫©n th·∫≠n khi ra ngo√†i. Tr√°nh ·ªü d∆∞·ªõi c√¢y cao v√† c√°c v·∫≠t d·ª•ng c√≥ th·ªÉ b·ªã gi√≥ th·ªïi bay.',
                    source: 'H·ªá th·ªëng ph√°t hi·ªán t·ª± ƒë·ªông'
                });
            }
        }
        
        // Check 5: Special conditions for Vietnam regions
        const location = weatherData.location.name.toLowerCase();
        const vietnamFloodProneAreas = [
            'h√† n·ªôi', 'hanoi', 'h·ªì ch√≠ minh', 'ho chi minh', 'ƒë√† n·∫µng', 'da nang',
            'hu·∫ø', 'hue', 'qu·∫£ng nam', 'quang nam', 'qu·∫£ng ng√£i', 'quang ngai',
            'ngh·ªá an', 'nghe an', 'h√† tƒ©nh', 'ha tinh', 'qu·∫£ng b√¨nh', 'quang binh',
            'th·ª´a thi√™n hu·∫ø', 'thua thien hue', 'c·∫ßn th∆°', 'can tho'
        ];
        
        const isFloodProneArea = vietnamFloodProneAreas.some(area => 
            location.includes(area)
        );
        
        if (isFloodProneArea && current.precip_mm > 20) {
            alerts.push({
                level: 'warning',
                title: 'C·∫£nh B√°o Khu V·ª±c D·ªÖ Ng·∫≠p',
                description: `${weatherData.location.name} l√† khu v·ª±c th∆∞·ªùng xuy√™n c√≥ nguy c∆° ng·∫≠p √∫ng. Hi·ªán ƒëang c√≥ m∆∞a ${current.precip_mm}mm.`,
                details: 'ƒê√¢y l√† khu v·ª±c d·ªÖ b·ªã ·∫£nh h∆∞·ªüng b·ªüi l≈© l·ª•t. H√£y chu·∫©n b·ªã s·∫µn s√†ng.',
                source: 'D·ªØ li·ªáu khu v·ª±c Vi·ªát Nam'
            });
        }
        
        // Show alert if any risks detected
        if (alerts.length > 0) {
            this.showAlert(alerts);
        }
        
        return alerts;
    }

    /**
     * Show flood alert banner (compact notification)
     */
    showAlert(alerts) {
        this.currentAlerts = alerts;
        
        // Update badge count
        this.badgeCount.textContent = alerts.length;
        
        // Find highest level alert
        let highestLevel = 'WARNING';
        alerts.forEach(alert => {
            const level = this.getDisasterLevel(alert);
            const levels = ['INFO', 'WARNING', 'DANGER', 'EXTREME'];
            if (levels.indexOf(level) > levels.indexOf(highestLevel)) {
                highestLevel = level;
            }
        });
        
        // Show banner with first/most important alert
        const mainAlert = alerts[0];
        const levelInfo = CONFIG.DISASTER_LEVELS[highestLevel] || CONFIG.DISASTER_LEVELS.WARNING;
        const levelText = `${levelInfo.emoji} ${levelInfo.label.toUpperCase()}`;
        
        this.alertTitle.textContent = levelText;
        this.alertMessage.textContent = mainAlert.description;
        
        // Prepare modal content
        let html = '';
        alerts.forEach((alert, index) => {
            const alertLevel = this.getDisasterLevel(alert);
            const levelInfo = CONFIG.DISASTER_LEVELS[alertLevel] || CONFIG.DISASTER_LEVELS.WARNING;
            const levelText = `${levelInfo.emoji} ${levelInfo.label.toUpperCase()}`;
            
            html += `
                ${index > 0 ? '<hr style="margin: 20px 0; border: none; border-top: 1px solid rgba(0,0,0,0.1);">' : ''}
                <div class="alert-item">
                    <div class="alert-level ${levelInfo.class}">${levelText}</div>
                    <h3 style="font-size: 1.3rem; font-weight: 800; margin: 10px 0; color: var(--text-primary);">
                        ${alert.title}
                    </h3>
                    <p style="margin: 10px 0;">${alert.description}</p>
                    ${alert.details ? `
                        <div class="alert-details">
                            <strong>Chi ti·∫øt:</strong> ${alert.details}
                        </div>
                    ` : ''}
                    <p style="margin-top: 10px; font-size: 0.9rem; color: var(--text-secondary);">
                        <i class="fas fa-broadcast-tower"></i> ${alert.source}
                    </p>
                </div>
            `;
        });
        
        this.messageContainer.innerHTML = html;
        
        // ONLY show banner, NOT badge (badge appears when banner is closed)
        this.badge.classList.add('hidden');
        this.banner.classList.remove('hidden');
        
        // Play alert sound with proper disaster level
        this.playAlertSound();
    }

    /**
     * Show banner (from badge click)
     */
    showBanner() {
        this.banner.classList.remove('hidden');
        // Hide badge when banner is shown
        this.badge.classList.add('hidden');
    }

    /**
     * Hide banner (show badge as reminder)
     */
    hideBanner() {
        this.banner.classList.add('hidden');
        // Show badge with smooth animation
        this.showBadgeWithAnimation();
    }
    
    /**
     * Show badge with smooth slide-in animation
     */
    showBadgeWithAnimation() {
        // Remove hidden class
        this.badge.classList.remove('hidden');
        
        // Force reflow to restart animation
        void this.badge.offsetWidth;
        
        // Add animation class
        this.badge.style.animation = 'none';
        setTimeout(() => {
            this.badge.style.animation = 'badgeFloat 3s ease-in-out infinite, badgeSlideIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1)';
        }, 10);
    }

    /**
     * Hide badge (when user acknowledges alert)
     */
    hideBadge() {
        this.badge.classList.add('hidden');
    }

    /**
     * Show modal with details
     */
    showModal() {
        this.modal.classList.remove('hidden');
    }

    /**
     * Hide modal
     */
    hideModal() {
        this.modal.classList.add('hidden');
    }

    /**
     * Check if alert sound is enabled
     */
    isSoundEnabled() {
        const saved = localStorage.getItem(CONFIG.STORAGE_KEYS.ALERT_SOUND_ENABLED);
        if (saved !== null) {
            return saved === 'true';
        }
        return CONFIG.ALERT_SOUND.ENABLED;
    }


    /**
     * Get disaster level from alert
     */
    getDisasterLevel(alert) {
        const level = alert.level || 'warning';
        if (level === 'extreme') return 'EXTREME';
        if (level === 'danger') return 'DANGER';
        if (level === 'warning') return 'WARNING';
        return 'INFO';
    }

    /**
     * Play advanced alert sound with multi-level disaster patterns
     */
    playAlertSound() {
        // Check if sound is enabled
        if (!this.isSoundEnabled()) {
            return;
        }

        if (!this.currentAlerts || this.currentAlerts.length === 0) {
            return;
        }

        // Store pending sound if audio context not unlocked yet
        if (!this.audioContextUnlocked) {
            this.pendingSound = true;
            // Try to unlock by creating a silent click event
            try {
                const clickEvent = new MouseEvent('click', { bubbles: true });
                document.dispatchEvent(clickEvent);
            } catch (e) {
                // Silent fail
            }
            return;
        }

        // Determine the highest alert level
        let maxLevel = 'WARNING';
        this.currentAlerts.forEach(alert => {
            const level = this.getDisasterLevel(alert);
            const levels = ['INFO', 'WARNING', 'DANGER', 'EXTREME'];
            if (levels.indexOf(level) > levels.indexOf(maxLevel)) {
                maxLevel = level;
            }
        });
        
        try {
            // Create or reuse audio context
            let audioContext;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (error) {
                console.log('Audio context creation failed:', error);
                this.pendingSound = true;
                return;
            }
            
            // Resume audio context if suspended (required for autoplay policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('Audio context resumed');
                    // Retry playing sound after resume
                    setTimeout(() => {
                        if (this.currentAlerts && this.currentAlerts.length > 0) {
                            this.playAlertSound();
                        }
                    }, 50);
                }).catch(err => {
                    console.log('Audio context resume failed:', err);
                    this.pendingSound = true;
                });
                return; // Exit early, will retry after resume
            }
            
            // Select pattern based on disaster level
            let pattern;
            switch(maxLevel) {
                case 'EXTREME':
                    pattern = CONFIG.ALERT_SOUND.EXTREME_PATTERN;
                    break;
                case 'DANGER':
                    pattern = CONFIG.ALERT_SOUND.DANGER_PATTERN;
                    break;
                case 'WARNING':
                    pattern = CONFIG.ALERT_SOUND.WARNING_PATTERN;
                    break;
                default:
                    pattern = CONFIG.ALERT_SOUND.INFO_PATTERN;
            }
            
            const volume = CONFIG.ALERT_SOUND.VOLUME;
            let currentTime = audioContext.currentTime;

            // Create multiple oscillator nodes for polyphonic sound
            pattern.tones.forEach((tone, toneIndex) => {
                for (let rep = 0; rep < pattern.repetitions; rep++) {
                    const repDelay = rep * (pattern.duration + pattern.pause) * pattern.tones.length;
                    const toneDelay = toneIndex * (pattern.duration + pattern.pause);
                    const startTime = currentTime + repDelay + toneDelay;

                    // Create oscillator for this tone
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Configure oscillator - use pattern waveType or default based on level
                    oscillator.frequency.value = tone;
                    oscillator.type = pattern.waveType || (maxLevel === 'EXTREME' || maxLevel === 'DANGER' ? 'square' : 'sine');
                    
                    // Create envelope for smooth attack and release
                    const attackTime = 0.005;
                    const sustainLevel = volume * (maxLevel === 'EXTREME' ? 1.0 : maxLevel === 'DANGER' ? 0.8 : 0.6);
                    const releaseTime = pattern.duration * 0.25;
                    
                    gainNode.gain.setValueAtTime(0, startTime);
                    gainNode.gain.linearRampToValueAtTime(sustainLevel, startTime + attackTime);
                    gainNode.gain.setValueAtTime(sustainLevel, startTime + pattern.duration - releaseTime);
                    gainNode.gain.linearRampToValueAtTime(0, startTime + pattern.duration);
                    
                    oscillator.start(startTime);
                    oscillator.stop(startTime + pattern.duration);
                }
            });

            // Add low-frequency rumble for danger/extreme alerts
            if (pattern.hasRumble && (maxLevel === 'DANGER' || maxLevel === 'EXTREME')) {
                const rumbleOsc = audioContext.createOscillator();
                const rumbleGain = audioContext.createGain();
                const rumbleFilter = audioContext.createBiquadFilter();
                
                rumbleOsc.type = 'sawtooth';
                rumbleOsc.frequency.value = maxLevel === 'EXTREME' ? 60 : 80; // Lower for extreme
                
                rumbleFilter.type = 'lowpass';
                rumbleFilter.frequency.value = maxLevel === 'EXTREME' ? 150 : 200;
                
                rumbleOsc.connect(rumbleFilter);
                rumbleFilter.connect(rumbleGain);
                rumbleGain.connect(audioContext.destination);
                
                const rumbleVolume = maxLevel === 'EXTREME' ? volume * 0.4 : volume * 0.3;
                
                rumbleGain.gain.setValueAtTime(0, currentTime);
                rumbleGain.gain.linearRampToValueAtTime(rumbleVolume, currentTime + 0.1);
                rumbleGain.gain.setValueAtTime(rumbleVolume, currentTime + pattern.totalTime - 0.2);
                rumbleGain.gain.linearRampToValueAtTime(0, currentTime + pattern.totalTime);
                
                rumbleOsc.start(currentTime);
                rumbleOsc.stop(currentTime + pattern.totalTime);
            }

            // Add siren effect for EXTREME level (rising/falling tone)
            if (pattern.hasSiren && maxLevel === 'EXTREME') {
                const sirenOsc = audioContext.createOscillator();
                const sirenGain = audioContext.createGain();
                const sirenLFO = audioContext.createOscillator(); // Low frequency oscillator for modulation
                const sirenGainMod = audioContext.createGain();
                
                // Main siren oscillator
                sirenOsc.type = 'square';
                sirenOsc.frequency.value = 600;
                
                // LFO modulates the frequency for siren effect
                sirenLFO.type = 'sine';
                sirenLFO.frequency.value = 2; // 2 Hz modulation
                
                sirenGainMod.gain.value = 400; // Modulation depth
                
                sirenLFO.connect(sirenGainMod);
                sirenGainMod.connect(sirenOsc.frequency);
                
                sirenOsc.connect(sirenGain);
                sirenGain.connect(audioContext.destination);
                
                sirenGain.gain.setValueAtTime(0, currentTime);
                sirenGain.gain.linearRampToValueAtTime(volume * 0.5, currentTime + 0.2);
                sirenGain.gain.setValueAtTime(volume * 0.5, currentTime + pattern.totalTime - 0.3);
                sirenGain.gain.linearRampToValueAtTime(0, currentTime + pattern.totalTime);
                
                sirenLFO.start(currentTime);
                sirenOsc.start(currentTime);
                sirenLFO.stop(currentTime + pattern.totalTime);
                sirenOsc.stop(currentTime + pattern.totalTime);
            }

        } catch (error) {
            // Silent fail if Web Audio API not supported
            console.log('Audio alert not available:', error);
            // Store as pending sound - will try again on user interaction
            if (this.isSoundEnabled()) {
                this.pendingSound = true;
            }
        }
    }

    /**
     * Get safety tips based on alert level
     */
    getSafetyTips(level) {
        if (level === 'danger') {
            return [
                'DI CHUY·ªÇN NGAY ƒë·∫øn n∆°i cao v√† an to√†n',
                'T·∫Øt ƒëi·ªán v√† gas tr∆∞·ªõc khi r·ªùi kh·ªèi nh√†',
                'Mang theo t√†i li·ªáu quan tr·ªçng v√† thu·ªëc men c·∫ßn thi·∫øt',
                'KH√îNG ƒëi qua v√πng n∆∞·ªõc ch·∫£y xi·∫øt',
                'G·ªçi 113 ho·∫∑c 114 n·∫øu c·∫ßn c·ª©u h·ªô kh·∫©n c·∫•p'
            ];
        } else {
            return [
                'Theo d√µi tin t·ª©c th·ªùi ti·∫øt th∆∞·ªùng xuy√™n',
                'Chu·∫©n b·ªã ƒë·ªì d√πng c·∫ßn thi·∫øt v√† di chuy·ªÉn ƒë·∫øn n∆°i an to√†n',
                'Kh√¥ng ƒëi qua v√πng ng·∫≠p n∆∞·ªõc s√¢u',
                'Li√™n h·ªá c∆° quan ch·ª©c nƒÉng khi c·∫ßn h·ªó tr·ª£: 113',
                'Chu·∫©n b·ªã l∆∞∆°ng th·ª±c, n∆∞·ªõc u·ªëng v√† ƒë√®n pin d·ª± ph√≤ng'
            ];
        }
    }
}

// Create global flood alert instance
const floodAlertSystem = new FloodAlertSystem();

